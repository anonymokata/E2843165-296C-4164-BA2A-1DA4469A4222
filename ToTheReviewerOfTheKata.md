# RomanNumeralCalcLib
If you'd like to just skip to the code, you'll need to navigate here: RomanNumeralCalcLib/RomanNumeralCalc2/RomanNumeralCalc2/
  
Why are there 2 contributors? Why do you have an empty RomanCalcLib2? 

Embarrasingly, I tried to start a brand new github account for 2 reasons:  
  
1) I wanted a fresh start on the project because I wasn't happy with the way that the first attempt went (because I wasn't strict enough on following TDD and because I didn't like where my solution was going and I couldn't find a good place to fork that wasn't at the beginning)  
  
2) I deleted the ./metadata folder when I was attempting to do a hard reset of the repository. I was getting all sorts of errors and little did I know that all you had to do was to create the subfolders that eclipse was complaining about. Lesson learned. 

I changed the url that my commits wrote to, but I never checked the github repository until about 5 commits in and was terrified to learn that nothing was there! After seeing that it was all in RomanNumeralCalLib I thought...you know what? I don't care if I publish my mistakes. This is totally fine. So here we are. 

This exercise has been terrific. At first I thought that developing a solution using TDD was going to be super restrictive and was going to shape precisely how my program should be written. I actually think that's why my first solution was so poor. I started, thinking that I couldn't possibly go wrong if I just implemented TDD, but then ended up in a place where I was pinned to make massive changes in my code and breaking all of my tests, or starting from the beginning.

I have a (good?) habit of drawing lots of little ideas out on paper but I never actually wrote down what I wanted to do from front to back on my first attempt. On my second, I was sure that by laying out a plan and then using TDD to develop it, I would do a much better job. And to my surprise, not only did that happen, but developing in this way became very natural and made me focus on solving the explicit task at hand (and as someone who often wanders through several different classes when programming, this way is much better, for the most part). I even had a moment when writing the convert.c file when I thought "I would not have came to this conclusion so soon had I not written a test case for it first". Plus, I always know that I can write simple code for test cases and then refactor once I have working code. Combine that with the ability to walk back in time with version control and you quickly become completely fearless to make drastic refactoring changes. I like coding this way so much that I am starting to implement it at work in my C# applications, which is something I never considered before now. 

Thanks for reading if you made it this far. I started school about six years ago with the hopes of just making a better life for my family, but I have dreamed of being part of something bigger than myself since I realized that not only could I be an engineer, but that I was a pretty good one. I consider myself fortunate to have participated in this Kata exercise and I look forward to your comments and questions. 
  
Happy Coding,  
  
Brad 
